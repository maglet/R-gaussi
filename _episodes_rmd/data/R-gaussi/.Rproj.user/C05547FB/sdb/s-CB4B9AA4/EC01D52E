{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Exploring Data Frames\"\nteaching: 20\nexercises: 10\nquestions:\n- \"How can I get to know the structure a data frame?\"\n- \"How can I work with subsets of data in R?\"\nobjectives:\n- \"Be able to find basic properties of a data frames including size, class or type of the columns, names, and first few rows.\"\n- \"Be able to articulate what a `factor` is and how to convert between `factor` and `character`.\"\n- \"To be able to subset data frames\"\n- \"To be able to extract individual and multiple elements by index, by name, using comparison operations\"\n\nkeypoints:\n- \"Read in a csv file using `read.csv()`\"\n- \"Use `str()`, `nrow()`, `ncol()`, `dim()`, `colnames()`, `rownames()`, `head()` and `typeof()` to understand structure of the data frame\"\n- \"Understand `length()` of a data frame\"\n- \"Use `levels()` and `as.character()` to explore and manipulate factors\"\n- \"Access individual values by location using `[]`.\"\n- \"Access slices of data using `[low:high]`.\"\n- \"Access arbitrary sets of data using `[c(...)]`.\"\n\nsource: Rmd\n---\n\n```{r, include=FALSE}\nsource(\"../bin/chunk-options.R\")\nknitr_fig_path(\"05-\")\n```\n\nIn this lesson, we'll learn about working with data frames using the gapminder\ndataset in your R project folder:\n\nTo load the data table into an R variable, use the `read.csv` function.\n\n```{r}\ngapminder <- read.csv(\"data/gapminder-FiveYearData.csv\")\n```\n\nLet's investigate gapminder a bit; the first thing we should always do is check out what the data looks like with `str`:\n\n```{r}\nstr(gapminder)\n```\n\nWe can also examine individual columns of the data frame with our `typeof` function:\n\n```{r}\ntypeof(gapminder$year)\ntypeof(gapminder$country)\nstr(gapminder$country)\n```\n\nWe can also interrogate the data frame for information about its dimensions;\nremembering that `str(gapminder)` said there were 1704 observations of 6\nvariables in gapminder, what do you think the following will produce, and why?\n\n```{r}\nlength(gapminder)\n```\n\nA fair guess would have been to say that the length of a data frame would be the\nnumber of rows it has (1704), but this is not the case; remember, a data frame\nis a *list of vectors and factors*:\n\n```{r}\ntypeof(gapminder)\n```\n\nWhen `length` gave us 6, it's because gapminder is built out of a list of 6\ncolumns. To get the number of rows and columns in our dataset, try:\n\n```{r}\nnrow(gapminder)\nncol(gapminder)\n```\n\nOr, both at once:\n\n```{r}\ndim(gapminder)\n```\n\nWe'll also likely want to know what the titles of all the columns are, so we can\nask for them later:\n\n```{r}\ncolnames(gapminder)\n```\n\nAt this stage, it's important to ask ourselves if the structure R is reporting\nmatches our intuition or expectations; do the basic data types reported for each\ncolumn make sense? If not, we need to sort any problems out now before they turn\ninto bad surprises down the road, using what we've learned about how R\ninterprets data, and the importance of *strict consistency* in how we record our\ndata.\n\nOnce we're happy that the data types and structures seem reasonable, it's time\nto start digging into our data proper. Check out the first few lines:\n\n```{r}\nhead(gapminder)\n```\n\nTo make sure our analysis is reproducible, we should put the code\ninto a script file so we can come back to it later.\n\n> ## Challenge 1\n>\n> Read the output of `str(gapminder)` again;\n> this time, use what you've learned about factors, lists and vectors,\n> as well as the output of functions like `colnames` and `dim`\n> to explain what everything that `str` prints out for gapminder means.\n> If there are any parts you can't interpret, discuss with your neighbors!\n>\n> > ## Solution to Challenge\n> >\n> > The object `gapminder` is a data frame with columns\n> > - `country` and `continent` are factors.\n> > - `year` is an integer vector.\n> > - `pop`, `lifeExp`, and `gdpPercap` are numeric vectors.\n> >\n> {: .solution}\n{: .challenge}\n\n## Subsetting\n\nThere are many instances where you want to use only a part of a dataset instead of the whole thing. That's where **subsetting** comes in. R has many powerful subset operators and mastering them will allow you to\neasily perform complex operations on any kind of dataset. \n\nSubsetting lets you select a single data element or separate based on a factor. For example, what if you want all of the data concerning countries in Asia in the gapminder dataset. \n\n\nThere are three ways to subset: by index, by name and by logical operators. Let's look at subsetting by index first. \n\n### Accessing elements using their indices\n\nTo simplify things, only look at one column of the data frame: `lifeExp`. From `str`, we know that it's the fifth column in the data frame. \n\nTo load the `lifeExp` column into a new variable x: \n\n```{r}\nx<-gapminder[,5]\n```\n\nThat means we want all of the fifth column loaded into x. Let's say we want to pick out the third element of x:\n\n```{r}\nx[3]\n```\n\nWe can ask for multiple elements at once using the `c`, or concatenate, function. `c` creates a vector of numbers that can be used for subsetting. For example, the following code creates a vector with the numbers 1 and 3 in it.\n\n```{r}\nc(1,3)\n```\n\nWe can use this vector inside the square brackets after x to get the first and third elements.\n```{r}\nx[c(1, 3)]\n```\n\nWe can also ask for slices of the vector using the `:` operator.\n\n```{r}\nx[1:4]\n```\n\nthe `:` operator creates a sequence of numbers from the left element to the right. \n```{r}\n1:4\n```\n\nYou can use the `c` function to do something similar\n```{r}\nc(1, 2, 3, 4)\n```\n\nIf we ask for a number outside of the vector, R will return missing values:\n\n```{r}\nx[1800]\n```\n\n### Data Frames\n\nLet's see how this subsetting thing works with whole data frames:\n\n1. An index between single brackets selects a column\n\n```{r}\nhead(gapminder[1])\n```\n\n2. If you want to select a single data point, you use [\"row\", \"column\"] format. The following selects the third row in the first column.\n\n```{r}\nhead(gapminder[3,1])\n```\n\n3. What if you want to select an entire row? Keep the comma, but remove the number specifying the column \n\n```{r}\ngapminder[3,]\n```\n\n4. This works similarly if you want to select one column, but it's kind of redundant with #1 above.\n\n```{r}\nhead(gapminder[,1])\n```\n\n5. You can use the `c` function, and the `:` operator just like with a single column\n\n```{r}\ngapminder[1:3,]\ngapminder[c(1,3),]\n```\n\n> ## Tip: Getting help for operators\n>\n> Remember you can search for help on operators by wrapping them in quotes:\n> `help(\":\")` or `?\":\"`.\n>\n{: .callout}\n\n> ## Challenge 2\n>\n> 1. Why does `gapminder[1:20]` return an error? How does it differ from `gapminder[1:20, ]`?\n>\n>\n> 2. Create a new `data.frame` called `gapminder_small` that only contains rows 1 through 9\n> and 19 through 23. You can do this in one or two steps.\n>\n> > ## Solution to challenge 2\n> >\n> > 1.  `gapminder` is a data.frame so needs to be subsetted on two dimensions. `gapminder[1:20, ]` subsets the data to give the first 20 rows and all columns.\n> >\n> > 2. \n> >\n> > ```{r}\n> > gapminder_small <- gapminder[c(1:9, 19:23),]\n> > ```\n> {: .solution}\n{: .challenge}\n\n## Subsetting by name\n\nWe can extract elements by using their name, instead of index.\n\nThis is usually a much more reliable way to subset objects: the\nposition of various elements can often change when chaining together\nsubsetting operations, but the names will always remain the same!\n\n`[[` will act to extract *a single column*:\n\n```{r}\nhead(gapminder[[\"lifeExp\"]])\n```\n\nAnd `$` provides a convenient shorthand to extract columns by name:\n\n```{r}\nhead(gapminder$year)\n```",
    "created" : 1496884656241.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4053726726",
    "id" : "EC01D52E",
    "lastKnownWriteTime" : 1496883981,
    "last_content_update" : 1496883981,
    "path" : "~/Desktop/gitRepos/R-gaussi/_episodes_rmd/02-data-frames.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}